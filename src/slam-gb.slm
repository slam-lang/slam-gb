{
The Slim Compiler, written in Slim

Preston Precourt (prestosilver) 2022

TODO: Tiles
}

inc stdlib/mem.slm
inc stdlib/tables.slm
inc stdlib/arrays.slm
inc stdlib/log.slm
inc stdlib/os.slm
inc stdlib.slm

proc version 0 1
  "0.4.2" ret
end

{
This is a enum of all the operations
and identifiers in slam
}
enum
0   OP_BAD
    OP_NOP
    OP_PUSH
    OP_SUB
    OP_MUL
    OP_DIV
    OP_PLUS
    OP_SWAP
    OP_DUMP
    OP_COPY
    OP_COVR
    OP_READ
    OP_READC
    OP_PUTC
    OP_PUT
    OP_DISC
    OP_TILES
    OP_TILEM
    OP_LCD
    OP_PUSHP
    OP_CALLS
    OP_MULTI
    OP_RET
    OP_QUIT
    OP_LOCX
    OP_JUMPX
    OP_JUMP
    OP_IF
    OP_JNZ
    OP_GETP
    OP_CYCL
    OP_NQ
    OP_EQ
    OP_LT
    OP_GT
    OP_AND
    OP_XOR
    OP_OR
    OP_NOT
    OP_SYS0
    OP_SYS1
    OP_SYS2
    OP_SYS3
    OP_SYS4
    OP_SYS5
    OP_SYS6

    IDENT_INC 
    IDENT_GVAR
    IDENT_CLASS
    IDENT_CONST
    IDENT_ENUM
    IDENT_PROP
    IDENT_PROC
    IDENT_DO
    IDENT_VAR
    IDENT_END
end

{
some parsing flags for context
}
enum
0   CF_NONE

    CF_PROC_OUT
    CF_PROC_IN
    CF_PROC_NAME

    CF_CONST_VALUE
    CF_CONST_NAME

    CF_PROP_VALUE
    CF_PROP_NAME

    CF_INC

    CF_VAR

    CF_GVAR_VALUE
    CF_GVAR_NAME

    CF_ENUM_CONTENT
    CF_ENUM_START

    CF_CLASS
end

{
help message modes
}
enum
1   HELP_VERSION
    HELP_SHOW
    HELP_ARGS
    HELP_OUTPUT
end

const TAB_KEY_SIZE 20
const BIG_TAB_CAP 300000
const SML_TAB_CAP 100000
const READSIZE 2048
const STRING_BUF_CAP 100000
const LOCAL_CAP 1024
const IDENT_CAP 1024

gvar gvartab 8
gvar consttab 8
gvar proctab 8
gvar procstacktab 8

gvar cmdbuffer READSIZE
gvar _ 1 {add 1 char for reading}
gvar readbuffer READSIZE
gvar _ 1 {add 1 char for reading}
gvar blockbuffer READSIZE
gvar _ 1 {add 1 char for reading}

gvar stringbuffer STRING_BUF_CAP
gvar stringbufferlen int.SIZE
gvar inputfd int.SIZE
gvar outputfd int.SIZE

gvar cmdlineflags int.SIZE

gvar identstack int.SIZE

gvar classname 64
gvar outputbuffer 64
gvar inputbuffer 64
gvar cmdtmpbuffer 64
gvar tmpprocbuffer 64
gvar includebuffer 1024
gvar includetmpbuffer 1024

gvar parseflags int.SIZE

gvar parseaddr int.SIZE
gvar parsesubaddr int.SIZE
gvar parsestringidx int.SIZE
gvar parsememory int.SIZE

gvar parsestack int.SIZE
gvar parsestackblock int.SIZE

gvar parsememorylocal int.SIZE

gvar constname 64
gvar enumvalue int.SIZE
gvar propsize int.SIZE

gvar procname 64
gvar procstats int.SIZE

proc getescape 1 1
  copy 'e' == if [ disc 27 ret ]
  copy 'r' == if [ disc 13 ret ]
  copy 'n' == if [ disc 10 ret ]
  copy 't' == if [ disc 9  ret ]
  copy '0' == if [ disc 0  ret ]
  ret
end

proc getnameop 1 1
  OP_BAD
  covr "proc"  (cstr.eq) if [disc IDENT_PROC]
  covr "do"    (cstr.eq) if [disc IDENT_DO]
  covr "end"   (cstr.eq) if [disc IDENT_END]
  covr "inc"   (cstr.eq) if [disc IDENT_INC]
  covr "enum"  (cstr.eq) if [disc IDENT_ENUM]
  covr "var"   (cstr.eq) if [disc IDENT_VAR]
  covr "gvar"  (cstr.eq) if [disc IDENT_GVAR]
  covr "const" (cstr.eq) if [disc IDENT_CONST]
  covr "class" (cstr.eq) if [disc IDENT_CLASS]
  covr "prop"  (cstr.eq) if [disc IDENT_PROP]
  
  covr "nop"   (cstr.eq) if [disc OP_NOP]
  covr "-"     (cstr.eq) if [disc OP_SUB]
  covr "*"     (cstr.eq) if [disc OP_MUL]
  covr "/"     (cstr.eq) if [disc OP_DIV]
  covr "+"     (cstr.eq) if [disc OP_PLUS]
  covr "^"     (cstr.eq) if [disc OP_XOR]
  covr "."     (cstr.eq) if [disc OP_PLUS]
  covr "swap"  (cstr.eq) if [disc OP_SWAP]
  covr "dump"  (cstr.eq) if [disc OP_DUMP]
  covr "copy"  (cstr.eq) if [disc OP_COPY]
  covr "covr"  (cstr.eq) if [disc OP_COVR]
  covr "readc" (cstr.eq) if [disc OP_READC]
  covr "read"  (cstr.eq) if [disc OP_READ]
  covr "@"     (cstr.eq) if [disc OP_READ]
  covr "putc"  (cstr.eq) if [disc OP_PUTC]
  covr "put"   (cstr.eq) if [disc OP_PUT]
  covr "="     (cstr.eq) if [disc OP_PUT]
  covr "disc"  (cstr.eq) if [disc OP_DISC]
  covr "tiles" (cstr.eq) if [disc OP_TILES]
  covr "tilem" (cstr.eq) if [disc OP_TILEM]
  covr "lcd"   (cstr.eq) if [disc OP_LCD]
  covr "()"    (cstr.eq) if [disc OP_CALLS]
  covr "ret"   (cstr.eq) if [disc OP_RET]
  covr "quit"  (cstr.eq) if [disc OP_QUIT]
  covr "if"    (cstr.eq) if [disc OP_IF]
  covr "cycl"  (cstr.eq) if [disc OP_CYCL]
  covr "!="    (cstr.eq) if [disc OP_NQ]
  covr "=="    (cstr.eq) if [disc OP_EQ]
  covr "<"     (cstr.eq) if [disc OP_LT]
  covr ">"     (cstr.eq) if [disc OP_GT]
  covr "&&"    (cstr.eq) if [disc OP_AND]
  covr "||"    (cstr.eq) if [disc OP_OR]
  covr "!"     (cstr.eq) if [disc OP_NOT]
  covr "sys0"  (cstr.eq) if [disc OP_SYS0]
  covr "sys1"  (cstr.eq) if [disc OP_SYS1]
  covr "sys2"  (cstr.eq) if [disc OP_SYS2]
  covr "sys3"  (cstr.eq) if [disc OP_SYS3]
  covr "sys4"  (cstr.eq) if [disc OP_SYS4]
  covr "sys5"  (cstr.eq) if [disc OP_SYS5]
  covr "sys6"  (cstr.eq) if [disc OP_SYS6]
  swap disc
  
  ret
end

proc getopname 1 1
  (int.cstr)
  {TODO: reimplement}

  ret
end

proc checkpopb 2 0
  parsestackblock read swap -
  parsestackblock swap put disc
  parsestackblock read
  0 < if [
    copy (cstr.println)
    procstacktab read (tab.print)
    disc -1 quit
  ]
  disc
  ret
end

proc addstackb 1 0
  parsestackblock read swap +
  parsestackblock swap put disc

  ret
end


proc checkpop 2 0
  parsestack read swap -
  parsestack swap put disc
  parsestack read
  0 < if [
    copy (cstr.println)
    procstacktab read (tab.print)
    disc -1 quit
  ]
  disc
  ret
end

proc addstack 1 0
  parsestack read swap +
  parsestack swap put disc

  ret
end

proc identstackpush 1 0
  identstack read swap (seq.pushptr)
  disc

  ret
end

proc identstackpop 0 1
  identstack read (seq.popaddr) read swap disc

  ret
end

proc inner 1 1
  1 + copy
  copy (cstr.len) 1 - + 0 putc disc
  ret
end

proc getstringidx 0 1
  parsestringidx read
  copy 1 +
  parsestringidx swap put disc
  ret
end

proc getaddr 0 1
  parsesubaddr
  0 put disc

  parseaddr read
  copy 1 +
  parseaddr swap put disc
  ret
end

proc getsubaddr 0 1
  parsesubaddr read
  copy 1 +
  parsesubaddr swap put disc
  ret
end

proc clean 0 0
  {close output}
  outputfd read
  copy 0 != if [(os.close) 0]
  disc

  {close input}
  inputfd read
  copy 0 != if [(os.close) 0]
  disc
  
  identstack read
  copy 0 != if [(seq.free) 0]
  disc

  ret
end
  
proc exit 0 0
  (clean)

  -1 quit
  ret
end

proc noprocblock 0 0
  0 1 (log.level)
  "ERR"
  "Proc not found: " (log.msg)
  blockbuffer 1 + (log.cat)
  (log.log)
  (exit)

  ret
end


proc noproc 0 0
  0 1 (log.level)
  "ERR"
  "Proc not found: " (log.msg)
  cmdbuffer 1 + (log.cat)
  (log.log)
  (exit)
  
  ret
end

proc writeout 2 0
  outputfd read (os.write)
  ret
end

proc writeoutln 0 0
  `\n` (writeout)
  ret
end

proc setclassname 0 0
  cmdbuffer classname swap (cstr.cpy) disc disc

  IDENT_CLASS (identstackpush)

  parseflags
  CF_NONE
  put disc

  propsize
  0
  put disc

  ret
end

proc getexpandedname 1 1
  tmpprocbuffer (cstr.clear) disc
  classname (cstr.len) 0 != if [
    tmpprocbuffer copy (cstr.len) +
    classname (cstr.cpy) disc disc
    tmpprocbuffer copy (cstr.len) +
    "." (cstr.cpy) disc disc
  ]
  tmpprocbuffer copy (cstr.len) +
  swap (cstr.cpy) disc disc
  tmpprocbuffer

  ret
end

proc getconst 0 1
  NULL
  consttab read cmdbuffer (tab.in) swap disc ! if [ disc cmdbuffer (cstr.tonum) ret ]
  disc
  consttab read cmdbuffer (tab.get)
  swap disc
  
  ret
end

proc addproc 0 0
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  parseflags copy read
  copy CF_PROC_NAME == if [
    proctab read
    cmdbuffer (getexpandedname) parseaddr read (tab.put) disc
    procname (cstr.clear) cmdbuffer (cstr.cpy) disc disc
  ] copy CF_PROC_IN == if [
    procstats
    cmdbuffer (cstr.tonum) 255 &&
    put disc

    parsestack
    cmdbuffer (cstr.tonum) 255 &&
    put disc
  ] copy CF_PROC_OUT == if [
    procstats
    procstats read
    cmdbuffer (cstr.tonum) 255 &&
    4294967296 * ||
    put disc
    procstacktab read
    procname (getexpandedname) procstats read (tab.put) disc
    (writeoutln)
  ]
  1 -
  putc disc

  ret
end

proc addprop 0 0
  parseflags
  copy read 1 - copy
  CF_PROP_VALUE 1 - == if [      
    consttab read constname (getexpandedname) propsize read (tab.put) disc

    propsize
    copy read
    (getconst) +
    put disc

    disc CF_NONE
  ] copy CF_PROP_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.cpy) disc disc
  ]
  put disc

  ret
end

proc addconst 0 0
  parseflags
  copy read 1 - copy
  CF_CONST_VALUE 1 - == if [
    consttab read constname (getexpandedname) (getconst) (tab.put) disc
    disc CF_NONE
  ] copy CF_CONST_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.cpy) disc disc
  ]
  put disc

  ret
end

proc addgvar 0 0
  parseflags
  copy read 1 -
  copy CF_GVAR_VALUE 1 - == if [
    constname (cstr.print)
    ": " (cstr.print)
    parsememory read 49408 + (int.printhex)
    gvartab read constname (getexpandedname) parsememory read (tab.put) disc
    (getconst)
    parsememory read +
    parsememory swap put disc
    disc CF_NONE
  ] copy CF_GVAR_NAME 1 - == if [
    cmdbuffer constname (cstr.clear) swap (cstr.cpy) disc disc
  ]
  put disc

  ret
end

proc addenumstart 0 0
  enumvalue
  cmdbuffer (cstr.tonum)
  put disc

  parseflags
  CF_ENUM_CONTENT
  put disc

  ret
end

proc addenum 0 0 
  cmdbuffer (cstr.isnum) if [
    enumvalue
    cmdbuffer (cstr.tonum)
    put disc

    ret
  ]

  cmdbuffer "end" (cstr.eq) if [
    parseflags
    CF_NONE
    put disc
    ret
  ]

  consttab read cmdbuffer (getexpandedname) enumvalue read (tab.put) disc

  enumvalue read
  1 +
  enumvalue swap put disc

  ret
end

proc addinc 0 0 
  parseflags
  CF_NONE
  put disc

  ret
end

proc addvar 0 0
  1 (addstack)

  `    ld hl, mem+` (writeout)
  parsememory read (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)
  `    push hl\n` (writeout)

  cmdbuffer (cstr.tonum)
  parsememory read +
  parsememory swap put
  disc

  parseflags
  CF_NONE
  put disc

  ret
end

proc asmheader 0 0
    stringbufferlen 1 put disc
    `DEF ret_stack_rsp EQU $C000\n` (writeout)
    `DEF ret_stack EQU $C001\n` (writeout)
    `DEF mem EQU $C100\n` (writeout)
    `SECTION "Header", ROM0[$100]\n` (writeout)
    `    jp start\n` (writeout)
    `    ds $150 - @, 0\n` (writeout)
    (writeoutln)
    ret
end

proc asmfooter 0 0
  "used memory: " (cstr.print)
  parsememory read (int.cstr) (cstr.print)
  "b" (cstr.println)
  `addr_` (writeout)
  (getaddr) (int.cstr) copy (cstr.len) swap (writeout)
  `:\n` (writeout)
  `    ret\n` (writeout)
  `lcd:\n` (writeout)
  `    ld hl, $FF41\n` (writeout)  
  `lcdw:\n` (writeout)
  `    bit 1, [hl]\n` (writeout)  
  `    jr nz, lcdw\n` (writeout)  
  `    ret\n` (writeout)  
  `divi:\n` (writeout)
  `    xor a\n` (writeout)
  `    ld b, 16\n` (writeout)
  `div_loop:\n` (writeout)
  `    add hl, hl\n` (writeout)
  `    rla\n` (writeout)
  `    cp d\n` (writeout)
  `    jp c, div_next\n` (writeout)
  `    sub d\n` (writeout)
  `    inc l\n` (writeout)
  `div_next:\n` (writeout)
  `    dec b\n` (writeout)
  `    jp nz, div_loop\n` (writeout)
  `    ret\n` (writeout)  
  `multi:\n` (writeout)
  `    ld a, 16\n` (writeout)  
  `    ld hl, 0\n` (writeout)  
  `multi_loop:\n` (writeout)
  `    srl b\n` (writeout)  
  `    rr c\n` (writeout)  
  `    jr nc, no_add\n` (writeout)  
  `    add hl, de\n` (writeout)  
  `no_add:\n` (writeout)
  `    push de\n` (writeout)  
  `    push hl\n` (writeout)  
  `    pop de\n` (writeout)  
  `    pop hl\n` (writeout)  
  `    add hl, hl\n` (writeout)  
  `    push de\n` (writeout)  
  `    push hl\n` (writeout)  
  `    pop de\n` (writeout)  
  `    pop hl\n` (writeout)  
  `    dec a\n` (writeout)  
  `    jr nz, multi_loop\n` (writeout)  
  `    ret\n` (writeout)  
  `start:\n` (writeout)
  `    ld a, HIGH(quit)\n` (writeout)
  `    ld [ret_stack_rsp + 1], a\n` (writeout)
  `    ld a, LOW(quit)\n` (writeout)
  `    ld [ret_stack_rsp + 2], a\n` (writeout)
  `    jp addr_` (writeout)
  proctab read
  "main" (tab.in) ! if [
    "no main proc defined" (cstr.println)
    (exit)
  ]
  "main" (tab.get) 1 - (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)
  `quit:\n` (writeout)
  `    jp quit\n` (writeout)
  `SECTION "Tile Data", ROM0\n` (writeout)
  `Tiles:\n` (writeout)
  `INCBIN "game/lol.2bpp" \n` (writeout)
  `SECTION "Tile Map", ROM0\n` (writeout)
  `Tilemap:\n` (writeout)
  `INCBIN "game/map.bin" \n` (writeout)
  disc
  ret
end

proc endopasm 1 0
  copy IDENT_DO == if [
    "do - end" 1 (checkpop)
    `    pop bc\n` (writeout)
    `    ld a, c\n` (writeout)
    `    cp a, 0\n` (writeout)
    `    jp nz, addr_` (writeout)
    (identstackpop) copy (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    ld a, b\n` (writeout)
    `    cp a, 0\n` (writeout)
    `    jp nz, addr_` (writeout)
    (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jp addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
  ]
  copy IDENT_CLASS == if [
    consttab read
    "SIZE" (getexpandedname) propsize read (tab.put)
    disc
    classname (cstr.clear) disc
  ]
  disc
  ret
end

proc endopblockasm 1 0
  copy IDENT_DO == if [
    "do - end" 1 (checkpopb)
    `    pop bc\n` (writeout)
    `    cp bc, bc\n` (writeout)
    `    jp z, addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jp addr_` (writeout)
    (identstackpop) (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    (identstackpop) (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
  ]
  disc
  ret
end

proc writeaddr 0 0
  `addr_` (writeout)
  (getaddr) (int.cstr) copy (cstr.len) swap (writeout)
  `:` (writeout)
  (writeoutln)

  {
  parsestack read (int.print)
  cmdbuffer (cstr.println)
  }

  ret
end

proc writesubaddr 0 0
  `addr_` (writeout)
  parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
  `_` (writeout)
  (getsubaddr) (int.cstr) copy (cstr.len) swap (writeout)
  `:` (writeout)
  (writeoutln)

  ret
end

proc badblockop 0 0
  "BAD OPERATION: " (cstr.println)
  "`" (cstr.print) blockbuffer (cstr.print) "`" (cstr.println)
  (exit)

  ret
end


proc checkbadblock 1 1
  blockbuffer (cstr.len) 3 ==
  blockbuffer readc ''' == &&
  blockbuffer (cstr.last) ''' == && if [
    blockbuffer 1 + readc
    (int.cstr)

    blockbuffer (cstr.clear) swap (cstr.cpy) disc disc

    disc OP_PUSH
    ret
  ]
  proctab read blockbuffer (tab.in) if [
    disc
    disc OP_PUSHP    
    ret
  ] disc
  consttab read blockbuffer (tab.in) if [
    blockbuffer (tab.get) swap disc
    (int.cstrhex)
    blockbuffer (cstr.clear) swap (cstr.cpy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  gvartab read blockbuffer (tab.in) if [
    1 (addstackb)
    `    ld hl, mem+` (writeout)
    gvartab read blockbuffer (tab.get) swap disc (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln) disc
    `    push hl\n` (writeout)
    
    disc OP_NOP
    ret
  ] disc
  (badblockop)
  ret
end

proc badret 0 0
  procstacktab read
  procname (getexpandedname) (tab.get)
  4294967296 / disc
  255 && (int.print)

  procname (cstr.println)
  parsestack read (int.print)
  "Error: proc dosent return correct ammount" (cstr.println)
  -1 quit

  ret
end

proc getblockasm 1 1
  blockbuffer (cstr.isnum) if [
    disc
    OP_PUSH
  ]

  (writesubaddr)

  copy OP_BAD == if (checkbadblock)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    "push" 0 (checkpopb)
    1 (addstackb)
    `    ld bc, ` (writeout)
    blockbuffer copy (cstr.len) swap (writeout)
    (writeoutln)
    `    push bc\n` (writeout)
    ret
  ] copy OP_CALLS == if [
    "call" 1 (checkpopb)
    0 (addstackb)
    `    ld hl, [ret_stack_rsp]\n` (writeout)
    `    add hl, 2\n` (writeout)
    `    ld [ret_stack_rsp], bc\n` (writeout)
    `    ld [ab], addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    pop bc\n` (writeout)
    `    jp bc\n` (writeout)
    ret
  ] copy OP_PUSHP == if [
    "pushp" 0 (checkpopb)
    1 (addstackb)
    `    push addr_` (writeout)
    proctab read blockbuffer (tab.get) (int.cstr) copy (cstr.len) swap (writeout)
    {TODO: assert return is same}
    (writeoutln)
    disc
    ret
  ] copy OP_COPY == if [
    "copy" 1 (checkpopb)
    2 (addstackb)
    `    pop bc\n` (writeout)
    `    push bc\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SWAP == if [
    "swap" 2 (checkpopb)
    2 (addstackb)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    push bc\n` (writeout)
    `    push de\n` (writeout)
    ret
  ] copy OP_SUB == if [
    "sub" 2 (checkpopb)
    1 (addstackb)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    ld a, c\n` (writeout)
    `    sub a, e\n` (writeout)
    `    ld c, a\n` (writeout)
    `    ld a, b\n` (writeout)
    `    sbc a, d\n` (writeout)
    `    ld b, a\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_PLUS == if [
    "plus" 2 (checkpopb)
    1 (addstackb)
    `    pop hl\n` (writeout)
    `    pop de\n` (writeout)
    `    add hl, de\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_AND == if [
    "and" 2 (checkpopb)
    1 (addstackb)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    and bc, de\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_XOR == if [
    "xor" 2 (checkpopb)
    1 (addstackb)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    xor bc, de\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_OR == if [
    "or" 2 (checkpopb)
    1 (addstackb)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    or bc, de\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_NOT == if [
    "not" 1 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    ld a, c\n` (writeout)
    `    xor a, $FFFF\n` (writeout)
    `    ld c, a\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_MUL == if [
    "mul" 2 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    call multi\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_DIV == if [
    "div" 2 (checkpopb)
    2 (addstackb)
    `    pop hl\n` (writeout)
    `    pop de\n` (writeout)
    `    ld d, e\n` (writeout)
    `    call divi\n` (writeout)
    `    push hl\n` (writeout)
    `    ld d, 0\n` (writeout)
    `    ld e, a\n` (writeout)
    `    push de\n` (writeout)
    ret
  ] copy OP_COVR == if [
    "covr" 2 (checkpopb)
    3 (addstackb)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    push de\n` (writeout)
    `    push bc\n` (writeout)
    `    push de\n` (writeout)
    ret
  ] copy OP_TILEM == if [
    "argc" 0 (checkpopb)
    1 (addstackb)
    `    ld hl, Tilemap\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_TILES == if [
    "tiles" 0 (checkpopb)
    1 (addstackb)
    ret
  ] copy OP_LCD == if [
    "lcd" 0 (checkpopb)
    0 (addstackb)
    `    call lcd\n` (writeout)
    ret
  ] copy OP_QUIT == if [
    "quit" 0 (checkpopb)
    0 (addstackb)
    `    jp quit\n` (writeout)
    ret
  ] copy OP_RET == if [
    "ret" 0 (checkpopb)
    0 (addstackb)
    procstacktab read
    procname (getexpandedname) (tab.get)
    4294967296 /% disc
    255 &&
    parsestackblock read != if (badret)
    disc
    `    ld a, [ret_stack_rsp]\n` (writeout)
    `    ld h, 0\n` (writeout)
    `    ld l, a\n` (writeout)
    `    sub a, 2\n` (writeout)
    `    ld [ret_stack_rsp], a\n` (writeout)
    `    ld bc, ret_stack\n` (writeout)
    `    add hl, bc\n` (writeout)
    `    ld a, [hl]\n` (writeout)
    `    ld b, a\n` (writeout)
    `    inc hl\n` (writeout)
    `    ld a, [hl]\n` (writeout)
    `    ld h, b\n` (writeout)
    `    ld l, a\n` (writeout)
    `    jp hl\n` (writeout)
    ret
  ] copy OP_DISC == if [
    "disc" 1 (checkpopb)
    0 (addstackb)
    `    pop bc\n` (writeout)
    ret
  ] copy OP_READC == if [
    "readc" 1 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    ld d, 0\n` (writeout)
    `    ld a, [bc]\n` (writeout)
    `    ld e, a\n` (writeout)
    `    push de\n` (writeout)
    ret
  ] copy OP_READ == if [
    "read" 1 (checkpopb)
    1 (addstackb)
    `    pop de\n` (writeout)
    `    ld a, [de]\n` (writeout)
    `    ld h, a\n` (writeout)
    `    inc de\n` (writeout)
    `    ld a, [de]\n` (writeout)
    `    ld l, a\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_PUTC == if [
    "putc" 2 (checkpopb)
    1 (addstackb)
    `    pop de\n` (writeout)
    `    pop hl\n` (writeout)
    `    ld [hl], e\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_PUT == if [
    "put" 2 (checkpopb)
    1 (addstackb)
    `    pop de\n` (writeout)
    `    pop hl\n` (writeout)
    `    ld [hl], d\n` (writeout)
    `    inc hl\n` (writeout)
    `    ld [hl], e\n` (writeout)
    `    dec hl\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_NQ == if [
    "nq" 2 (checkpopb)
    1 (addstackb)
    "nq" 2 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    ld hl, 0\n` (writeout)
    `    push hl\n` (writeout)
    `    ld a, d\n` (writeout)
    `    cp a, b\n` (writeout)
    `    jp nz, lol_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    ld a, e\n` (writeout)
    `    cp a, c\n` (writeout)
    `    jp z, addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `lol_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `:\n` (writeout)
    `    pop hl\n` (writeout)
    `    ld hl, 1\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_EQ == if [
    "eq" 2 (checkpopb)
    1 (addstackb)
    `    ld rcx, 0\n` (writeout)
    `    ld rdx, 1\n` (writeout)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    cmp bc, de\n` (writeout)
    `    clde rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_GT == if [
    "gt" 2 (checkpopb)
    1 (addstackb)
    `    ld rcx, 0\n` (writeout)
    `    ld rdx, 1\n` (writeout)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    cmp bc, de\n` (writeout)
    `    cldg rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_LT == if [
    "lt" 2 (checkpopb)
    1 (addstackb)
    `    ld rcx, 0\n` (writeout)
    `    ld rdx, 1\n` (writeout)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    cmp bc, de\n` (writeout)
    `    cldl rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_IF == if [
    "if" 1 (checkpopb)
    0 (addstackb)
    `    pop de\n` (writeout)
    `    ld a, e\n` (writeout)
    `    cp a, 0\n` (writeout)
    `    jp z, addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read 1 + (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    "sys0" 1 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS1 == if [
    "sys1" 2 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS2 == if [
    "sys2" 3 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS3 == if [
    "sys3" 4 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS4 == if [
    "sys4" 5 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS5 == if [
    "sys5" 6 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS6 == if [
    "sys6" 7 (checkpopb)
    1 (addstackb)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    pop r9\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_DUMP == if [
    "dump" 1 (checkpopb)
    0 (addstackb)
    `    pop bc\n` (writeout)
    `    call print\n` (writeout)
    ret
  ] copy IDENT_END == if [
    "end" 0 (checkpopb)
    0 (addstackb)
    (identstackpop)
    (endopblockasm)
    ret
  ] copy IDENT_DO == if [
    "do" 0 (checkpopb)
    0 (addstackb)
    parsesubaddr read 1 - (identstackpush)
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_GVAR == if [
    "gvar" 0 (checkpopb)
    0 (addstackb)
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    "var" 0 (checkpopb)
    0 (addstackb)
    parseflags
    CF_VAR
    put disc
    ret
  ]
  copy
  {TODO: log this}
  `; unimp ` (writeout)
  (getopname) copy (cstr.len) swap (writeout)
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  (writeoutln)
  ret
end

proc parsestring 0 0

  { add code }
  1 (addstackb)
  `    push str_` (writeout)
  (getstringidx) (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)

  { put the header }
  `str_`
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (int.cstr)
  copy (cstr.len) swap
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  `: db `
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  blockbuffer 1 +

  { put the first char }
  copy readc
  (int.cstr)
  copy (cstr.len) swap
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    `, `
    stringbuffer stringbufferlen read +
    swap (cstr.cpy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (int.cstr)
    copy (cstr.len) swap
    stringbuffer stringbufferlen read +
    swap (cstr.cpy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  `\n`
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  disc

  blockbuffer (cstr.clear) disc
  ret
end

proc parseblockcmd 0 0
  blockbuffer readc '{' == blockbuffer (cstr.last) '}' == && if [
    {comment}

    nop

    blockbuffer (cstr.clear) disc
  ] blockbuffer readc '"' == blockbuffer (cstr.last) '"' == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner)
    (parsestring)

    disc ret
  ] blockbuffer readc '`' == blockbuffer (cstr.last) '`' == && if [
    {string}
    (writesubaddr)

    blockbuffer (inner) disc
    1 (addstackb)
    `    push ` (writeout)
    blockbuffer 1 + (cstr.len) (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    
    (parsestring)
    ret
  ] blockbuffer readc '(' == blockbuffer (cstr.last) ')' == && blockbuffer (cstr.len) 2 != && if [
    {call}

    (writesubaddr)
    `    ld a, [ret_stack_rsp]\n` (writeout)
    `    add a, 2\n` (writeout)
    `    ld [ret_stack_rsp], a\n` (writeout)
    `    ld h, 0\n` (writeout)
    `    ld l, a\n` (writeout)
    `    ld bc, ret_stack\n` (writeout)
    `    add hl, bc\n` (writeout)
    `    ld [hl], HIGH(addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    `)\n` (writeout)
    `    inc hl\n` (writeout)
    `    ld [hl], LOW(addr_` (writeout)
    parseaddr read 1 - (int.cstr) copy (cstr.len) swap (writeout)
    `_` (writeout)
    parsesubaddr read (int.cstr) copy (cstr.len) swap (writeout)
    `)\n` (writeout)
    `    jp addr_` (writeout)
    blockbuffer (inner) disc
    proctab read
    blockbuffer 1 + (tab.in) ! if (noprocblock)
    blockbuffer 1 + (tab.get) (int.cstr)
    
    
    procstacktab read
    blockbuffer 1 + (tab.get)
    255 && blockbuffer 1 + swap (checkpopb)
    blockbuffer 1 + (tab.get)
    4294967296 /% disc
    255 && (addstackb)
    disc

    copy (cstr.len) swap
    (writeout)
    disc
    blockbuffer (cstr.clear) disc
    (writeoutln)
    ret
  ] blockbuffer readc 0 != if [
    parseflags read
    blockbuffer (getnameop)
    covr CF_NONE == if (getblockasm)
    covr CF_VAR == if (addvar)
    disc disc
  ]
  blockbuffer (cstr.clear) disc

  ret
end

proc badop 0 0
  "BAD OPERATION: " (cstr.println)
  "`" (cstr.print) cmdbuffer (cstr.print) "`" (cstr.println)
  (exit)

  ret
end

proc checkbad 1 1
  cmdbuffer (cstr.len) 3 ==
  cmdbuffer readc ''' == &&
  cmdbuffer (cstr.last) ''' == && if [
    cmdbuffer 1 + readc
    (int.cstr)

    cmdbuffer (cstr.clear) swap (cstr.cpy) disc disc

    disc OP_PUSH
    ret
  ]
  proctab read cmdbuffer (tab.in) if [
    disc
    disc OP_PUSHP    
    ret
  ] disc
  consttab read cmdbuffer (tab.in) if [
    cmdbuffer (tab.get) swap disc
    (int.cstrhex)
    cmdbuffer (cstr.clear) swap (cstr.cpy) disc disc
    
    disc OP_PUSH
    ret
  ] disc
  gvartab read cmdbuffer (tab.in) if [
    1 (addstack)
    `    ld hl, mem+` (writeout)
    gvartab read cmdbuffer (tab.get) swap disc (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln) disc
    `    push hl\n` (writeout)
    
    disc OP_NOP
    ret
  ] disc
  (badop)
  ret
end

proc getcmdasm 1 1
  cmdbuffer (cstr.isnum) if [
    disc
    OP_PUSH
  ]

  (writeaddr)
  copy OP_BAD == if (checkbad)
  copy OP_NOP == if [
    ret
  ] copy OP_PUSH == if [
    "push" 0 (checkpop)
    1 (addstack)
    `    ld bc, ` (writeout)
    cmdbuffer copy (cstr.len) swap (writeout)
    (writeoutln)
    `    push bc\n` (writeout)
    ret
  ] copy OP_CALLS == if [
    "call" 1 (checkpopb)
    0 (addstackb)
    `    ld hl, [ret_stack_rsp]\n` (writeout)
    `    add hl, 2\n` (writeout)
    `    ld [ret_stack_rsp], hl\n` (writeout)
    `    ld [hl], addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    pop bc\n` (writeout)
    `    jp bc\n` (writeout)
    ret
  ] copy OP_PUSHP == if [
    "pushp" 0 (checkpopb)
    1 (addstackb)
    `    push addr_` (writeout)
    proctab read cmdbuffer (tab.get) (int.cstr) copy (cstr.len) swap (writeout)
    {TODO: assert return is same}
    (writeoutln)
    disc
    ret
  ] copy OP_COPY == if [
    "copy" 1 (checkpop)
    2 (addstack)
    `    pop bc\n` (writeout)
    `    push bc\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SWAP == if [
    "swap" 2 (checkpop)
    2 (addstack)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    push bc\n` (writeout)
    `    push de\n` (writeout)
    ret
  ] copy OP_SUB == if [
    "sub" 2 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    ld a, c\n` (writeout)
    `    sub a, e\n` (writeout)
    `    ld c, a\n` (writeout)
    `    ld a, b\n` (writeout)
    `    sbc a, d\n` (writeout)
    `    ld b, a\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_PLUS == if [
    "plus" 2 (checkpop)
    1 (addstack)
    `    pop hl\n` (writeout)
    `    pop de\n` (writeout)
    `    add hl, de\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_AND == if [
    "and" 2 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    ld a, b\n` (writeout)
    `    and a, d\n` (writeout)
    `    ld b, a\n` (writeout)
    `    ld a, c\n` (writeout)
    `    and a, e\n` (writeout)
    `    ld c, a\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_XOR == if [
    "xor" 2 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    xor bc, de\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_OR == if [
    "or" 2 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    ld a, b\n` (writeout)
    `    or a, d\n` (writeout)
    `    ld b, a\n` (writeout)
    `    ld a, c\n` (writeout)
    `    or a, e\n` (writeout)
    `    ld c, a\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_NOT == if [
    "not" 1 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    ld a, c\n` (writeout)
    `    xor a, $FF\n` (writeout)
    `    ld c, a\n` (writeout)
    `    ld a, b\n` (writeout)
    `    xor a, $FF\n` (writeout)
    `    ld b, a\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_MUL == if [
    "mul" 2 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    call multi\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_DIV == if [
    "div" 2 (checkpop)
    2 (addstack)
    `    pop hl\n` (writeout)
    `    pop de\n` (writeout)
    `    ld d, e\n` (writeout)
    `    call divi\n` (writeout)
    `    push hl\n` (writeout)
    `    ld d, 0\n` (writeout)
    `    ld e, a\n` (writeout)
    `    push de\n` (writeout)
    ret
  ] copy OP_COVR == if [
    "covr" 2 (checkpop)
    3 (addstack)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    push de\n` (writeout)
    `    push bc\n` (writeout)
    `    push de\n` (writeout)
    ret
  ] copy IDENT_CLASS == if [
    "class" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_CLASS
    put disc
    ret
  ] copy IDENT_PROC == if [
    "proc" 0 (checkpop)
    0 (addstack)
    IDENT_PROC (identstackpush)
    `    ; - proc` (writeout)
    parseflags
    CF_PROC_NAME
    put disc
    ret
  ] copy IDENT_ENUM == if [
    "enum" 0 (checkpop)
    0 (addstack)
    `    ; - enum\n` (writeout)
    parseflags
    CF_ENUM_START
    put disc
    ret
  ] copy OP_TILEM == if [
    "argc" 0 (checkpop)
    1 (addstack)
    `    ld hl, Tilemap\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_TILES == if [
    "tiles" 0 (checkpop)
    1 (addstack)
    `    ld hl, Tiles\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_LCD == if [
    "lcd" 0 (checkpop)
    0 (addstack)
    `    call lcd\n` (writeout)
    ret
  ] copy OP_QUIT == if [
    "quit" 0 (checkpop)
    0 (addstack)
    `    jp quit\n` (writeout)
    ret
  ] copy OP_RET == if [
    "ret" 0 (checkpop)
    0 (addstack)
    procstacktab read
    procname (getexpandedname) (tab.get)
    4294967296 /% disc
    255 &&
    parsestack read != if (badret)
    disc
    `    ld a, [ret_stack_rsp]\n` (writeout)
    `    ld h, 0\n` (writeout)
    `    ld l, a\n` (writeout)
    `    sub a, 2\n` (writeout)
    `    ld [ret_stack_rsp], a\n` (writeout)
    `    ld bc, ret_stack\n` (writeout)
    `    add hl, bc\n` (writeout)
    `    ld a, [hl]\n` (writeout)
    `    ld b, a\n` (writeout)
    `    inc hl\n` (writeout)
    `    ld a, [hl]\n` (writeout)
    `    ld h, b\n` (writeout)
    `    ld l, a\n` (writeout)
    `    jp hl\n` (writeout)
    ret
  ] copy OP_DISC == if [
    "disc" 1 (checkpop)
    0 (addstack)
    `    pop bc\n` (writeout)
    ret
  ] copy IDENT_PROP == if [
    "prop" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_PROP_NAME
    put disc
    ret
  ] copy IDENT_CONST == if [
    "const" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_CONST_NAME
    put disc
    ret
  ] copy OP_READC == if [
    "readc" 1 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    ld d, 0\n` (writeout)
    `    ld a, [bc]\n` (writeout)
    `    ld e, a\n` (writeout)
    `    push de\n` (writeout)
    ret
  ] copy OP_READ == if [
    "read" 1 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    ld a, [de]\n` (writeout)
    `    ld h, a\n` (writeout)
    `    inc de\n` (writeout)
    `    ld a, [de]\n` (writeout)
    `    ld l, a\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_PUTC == if [
    "putc" 2 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    pop hl\n` (writeout)
    `    ld [hl], e\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_PUT == if [
    "put" 2 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    pop hl\n` (writeout)
    `    ld [hl], d\n` (writeout)
    `    inc hl\n` (writeout)
    `    ld [hl], e\n` (writeout)
    `    dec hl\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_NQ == if [
    "nq" 2 (checkpop)
    1 (addstack)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    ld hl, 0\n` (writeout)
    `    push hl\n` (writeout)
    `    ld a, d\n` (writeout)
    `    cp a, b\n` (writeout)
    `    jp nz, lol_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    ld a, e\n` (writeout)
    `    cp a, c\n` (writeout)
    `    jp z, addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `lol_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    `:\n` (writeout)
    `    pop hl\n` (writeout)
    `    ld hl, 1\n` (writeout)
    `    push hl\n` (writeout)
    ret
  ] copy OP_EQ == if [
    "eq" 2 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    cp bc, de\n` (writeout)
    `    push 1\n` (writeout)
    `    jp z, addr_` (writeout)
    parseaddr read 1 + (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    pop bc\n` (writeout)
    `    push 0\n` (writeout)
    ret
  ] copy OP_GT == if [
    "gt" 2 (checkpop)
    1 (addstack)
    `    ld rcx, 0\n` (writeout)
    `    ld rdx, 1\n` (writeout)
    `    pop de\n` (writeout)
    `    pop bc\n` (writeout)
    `    cmp bc, de\n` (writeout)
    `    cldg rcx, rdx\n` (writeout)
    `    push rcx\n` (writeout)
    ret
  ] copy OP_LT == if [
    "lt" 2 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop de\n` (writeout)
    `    ld hl, 1\n` (writeout)
    `    push hl\n` (writeout)
    `    ld a, b\n` (writeout)
    `    cp a, d\n` (writeout)
    `    jp c, lol_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    jp nz, addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `    ld a, c\n` (writeout)
    `    cp a, e\n` (writeout)
    `    jp nc, addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    `lol_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    `:\n` (writeout)
    `    pop bc\n` (writeout)
    `    ld bc, 0\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_IF == if [
    "if" 1 (checkpop)
    0 (addstack)
    `    pop de\n` (writeout)
    `    ld a, e\n` (writeout)
    `    cp a, 0\n` (writeout)
    `    jp z, addr_` (writeout)
    parseaddr read 1 + (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    ret
  ] copy OP_SYS0 == if [
    "sys0" 1 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS1 == if [
    "sys1" 2 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS2 == if [
    "sys2" 3 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS3 == if [
    "sys3" 4 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS4 == if [
    "sys4" 5 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS5 == if [
    "sys5" 6 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_SYS6 == if [
    "sys6" 7 (checkpop)
    1 (addstack)
    `    pop bc\n` (writeout)
    `    pop rdi\n` (writeout)
    `    pop rsi\n` (writeout)
    `    pop rdx\n` (writeout)
    `    pop r10\n` (writeout)
    `    pop r8\n` (writeout)
    `    pop r9\n` (writeout)
    `    syscall\n` (writeout)
    `    push bc\n` (writeout)
    ret
  ] copy OP_DUMP == if [
    "dump" 1 (checkpop)
    0 (addstack)
    `    pop bc\n` (writeout)
    `    call print\n` (writeout)
    ret
  ] copy IDENT_INC == if [
    "inc" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_INC
    put disc
    ret
  ] copy IDENT_END == if [
    "end" 0 (checkpop)
    0 (addstack)
    (identstackpop)
    (endopasm)
    ret
  ] copy IDENT_DO == if [
    "do" 0 (checkpop)
    0 (addstack)
    parseaddr read 1 - (identstackpush)
    IDENT_DO (identstackpush)
    ret
  ] copy IDENT_GVAR == if [
    "gvar" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_GVAR_NAME
    put disc
    ret
  ] copy IDENT_VAR == if [
    "var" 0 (checkpop)
    0 (addstack)
    parseflags
    CF_VAR
    put disc
    ret
  ]
  copy
  {TODO: log this}
  `; unimp ` (writeout)
  (getopname) copy (cstr.len) swap (writeout)
  ` ` (writeout)
  cmdbuffer copy (cstr.len) swap (writeout)
  (writeoutln)
  ret
end

proc checkcmd 0 1
  cmdbuffer readc '"' == cmdbuffer (cstr.last) '"' != &&
  cmdbuffer readc ''' == cmdbuffer (cstr.last) ''' != && ||
  cmdbuffer readc '`' == cmdbuffer (cstr.last) '`' != && ||
  cmdbuffer readc '[' == cmdbuffer (cstr.last) ']' != && ||
  cmdbuffer readc '{' == cmdbuffer (cstr.last) '}' != && ||
  cmdbuffer "`" (cstr.eq) ||
  cmdbuffer """ (cstr.eq) ||
  cmdbuffer "'" (cstr.eq) ||
  !

  ret
end

proc checkblockcmd 0 1
  blockbuffer readc '"' == blockbuffer (cstr.last) '"' != &&
  blockbuffer readc ''' == blockbuffer (cstr.last) ''' != && ||
  blockbuffer readc '`' == blockbuffer (cstr.last) '`' != && ||
  blockbuffer readc '[' == blockbuffer (cstr.last) ']' != && ||
  blockbuffer readc '{' == blockbuffer (cstr.last) '}' != && ||
  blockbuffer "`" (cstr.eq) ||
  blockbuffer """ (cstr.eq) ||
  blockbuffer "'" (cstr.eq) ||
  !

  ret
end

proc checkbufferblock 2 2
  { if the command is complete, get the buffer }
  (checkblockcmd) if [(parseblockcmd) disc disc blockbuffer 0 ret]

  { if the command is not complete, append a space }
  disc ' '

  ret
end

proc parseblock 0 0
  parsestackblock
  parsestack read
  put disc

  cmdbuffer
  blockbuffer
  do
    covr readc
    copy 9 {tab} ==
    covr 10 {lf} == ||
    covr 13 {cr} == ||
    covr 32 {spc} == ||
    if (checkbufferblock)

    blockbuffer readc

    copy '"' ==
    swap '`' == ||
    covr '\' == &&
    if [
      disc
      swap 1 +
      swap

      covr readc (getescape)
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc

  blockbuffer
  ' '
  (checkbufferblock)
  disc
  disc
  (writesubaddr)
  {
  parsestackblock read parsestack read == !
  if [
    cmdbuffer (cstr.print)
    " Bad Block" (cstr.println)
    parsestackblock read (int.print)
    parsestack read (int.print)
    -1 quit
  ]
  }
  ret
end

proc parsestringblock 0 0 

  { add code }
  1 (addstack)
  `    push str_` (writeout)
  (getstringidx) (int.cstr) copy (cstr.len) swap (writeout)
  (writeoutln)

  { put the header }
  `str_`
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  parsestringidx read 1 - (int.cstr)
  copy (cstr.len) swap
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  `: db `
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer 1 +

  { put the first char }
  copy readc
  (int.cstr)
  copy (cstr.len) swap
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc
  do
    1 +

    { comma }
    `, `
    stringbuffer stringbufferlen read +
    swap (cstr.cpy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc

    { put the next char }
    copy readc
    copy (int.cstr)
    copy (cstr.len) swap
    stringbuffer stringbufferlen read +
    swap (cstr.cpy) disc disc
    stringbufferlen read +
    stringbufferlen swap put disc
  end
  disc
  `\n`
  stringbuffer stringbufferlen read +
  swap (cstr.cpy) disc disc
  stringbufferlen read +
  stringbufferlen swap put disc

  cmdbuffer (cstr.clear) disc
  ret
end

proc parsecmd 0 0
  cmdbuffer readc '{' == cmdbuffer (cstr.last) '}' == && if [

    cmdbuffer (cstr.clear) disc
    ret
  ]
  cmdbuffer readc '"' == cmdbuffer (cstr.last) '"' == && if [
    (writeaddr)

    cmdbuffer (inner)
    (parsestringblock)
    disc ret
  ]
  cmdbuffer readc '`' == cmdbuffer (cstr.last) '`' == && if [
    {string}
    (writeaddr)

    cmdbuffer (inner) disc
    1 (addstack)
    `    push ` (writeout)
    cmdbuffer 1 + (cstr.len) (int.cstr) copy (cstr.len) swap (writeout)
    (writeoutln)
    
    (parsestringblock)
    ret
  ]
  cmdbuffer readc '[' == cmdbuffer (cstr.last) ']' == && if [
    (writeaddr)
    cmdbuffer (inner)
    cmdbuffer swap (cstr.cpy) disc disc
    cmdbuffer copy (cstr.len) 1 - + 0 putc disc
    (parseblock)
    cmdbuffer (cstr.clear) disc
    ret
  ]
  cmdbuffer readc '(' == cmdbuffer (cstr.last) ')' == && cmdbuffer (cstr.len) 2 != && if [
    { call }

    (writeaddr)
    `    ld a, [ret_stack_rsp]\n` (writeout)
    `    add a, 2\n` (writeout)
    `    ld [ret_stack_rsp], a\n` (writeout)
    `    ld h, 0\n` (writeout)
    `    ld l, a\n` (writeout)
    `    ld bc, ret_stack\n` (writeout)
    `    add hl, bc\n` (writeout)
    `    ld [hl], HIGH(addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    `)\n` (writeout)
    `    inc hl\n` (writeout)
    `    ld [hl], LOW(addr_` (writeout)
    parseaddr read (int.cstr) copy (cstr.len) swap (writeout)
    `)\n` (writeout)
    `    jp addr_` (writeout)
    cmdbuffer (inner) disc
    proctab read
    cmdbuffer 1 + (tab.in) ! if (noproc)
    cmdbuffer 1 + (tab.get) (int.cstr)
    
    procstacktab read
    cmdbuffer 1 + (tab.get)
    255 && cmdbuffer 1 + swap (checkpop)
    cmdbuffer 1 + (tab.get)
    4294967296 /% disc
    255 && (addstack)
    disc

    copy (cstr.len) swap
    (writeout)
    disc
    cmdbuffer (cstr.clear) disc
    (writeoutln)
    ret
  ]
  cmdbuffer readc 0 != if [
    parseflags read
    cmdbuffer (getnameop)
    covr CF_NONE == if (getcmdasm)
    covr CF_PROC_OUT == if (addproc)
    covr CF_PROC_IN == if (addproc)
    covr CF_PROC_NAME == if (addproc)
    covr CF_CONST_VALUE == if (addconst)
    covr CF_CONST_NAME == if (addconst)
    covr CF_PROP_VALUE == if (addprop)
    covr CF_PROP_NAME == if (addprop)
    covr CF_INC == if (addinc)
    covr CF_VAR == if (addvar)
    covr CF_GVAR_NAME == if (addgvar)
    covr CF_GVAR_VALUE == if (addgvar)
    covr CF_ENUM_CONTENT == if (addenum)
    covr CF_ENUM_START == if (addenumstart)
    covr CF_CLASS == if (setclassname)
    disc disc
  ]
  cmdbuffer (cstr.clear) disc
  ret
end

proc checkbuffer 2 2
  { if the command is complete, get the buffer }
  (checkcmd) if [(parsecmd) disc disc cmdbuffer 0 ret]

  { if the command is not complete, append a space }
  disc 32
  ret
end

{
args: ptr
result: ptr

parses a file
}
proc parsefile 0 0
  READSIZE readbuffer
  inputfd read (os.readf) disc
  inputfd read 74 sys1 disc
  do
    readbuffer
    cmdbuffer
    do
      covr readc

      copy 9 {tab} ==
      covr 10 {lf} == ||
      covr 13 {cr} == ||
      covr 32 {spc} == ||
      if (checkbuffer)

      cmdbuffer readc

      copy '"' ==
      swap '`' == ||
      covr '\' == &&
      if [
        disc
        swap 1 +
        swap

        covr readc (getescape)
      ]

      covr
      swap
      putc disc

      swap
      1 +
      swap
      copy readc 0 != if [
        1 +
      ]

      covr readc 0 !=
    end
    disc
    disc

    readbuffer (cstr.clear)

    cmdbuffer (cstr.cpy) disc disc

    READSIZE cmdbuffer (cstr.len) -

    readbuffer cmdbuffer (cstr.len) +

    inputfd read (os.readf) copy
    readbuffer + cmdbuffer (cstr.len) + 1 + copy readc 0 != if (cstr.clear) disc
    inputfd read 74 sys1 disc

    cmdbuffer (cstr.clear) disc
  end

  ret
end

{
args: int
result:

prints a help string
}
proc help 1 0
  copy HELP_VERSION == if [
    "slam-gb compiler v" (cstr.print) (version) (cstr.println)
    (exit)
  ]
  "Help"
  covr HELP_ARGS == if [
    disc
    "ERROR: You must compile exactly 1 file"
  ] covr HELP_OUTPUT == if [
    disc
    "ERROR: Last argument supplied requires a parameter"
  ]
  (cstr.println)
  "slam-gb compiler v" (cstr.print) (version) (cstr.print) " usage:" (cstr.println)
  (cstr.cr)
  "slam-gb [-h]\ [-a]\ [-s]\ [-i include]\ [-o output]\ file" (cstr.println)
  (cstr.cr)
  "-v            shows the version and exits." (cstr.println)
  "-h, --help    shows this help message."     (cstr.println)
  "-i, --include includes a library."          (cstr.println)
  "-s, --silent  disables output text."        (cstr.println)
  "-a, --asm     keeps the assembly code."     (cstr.println)
  "-o, --output  selects the output file."     (cstr.println)
  disc
  (exit)

  ret
end

{
args:
result:

sets the silent flag
}
proc setsilent 0 0
  cmdlineflags
  cmdlineflags read 1 ||
  put
  disc
  ret
end

proc setasm 0 0
  cmdlineflags
  cmdlineflags read 2 ||
  put
  disc
  ret
end

{
args: int
result: int

sets the output flag to the argument
}
proc setoutput 1 1
    copy argc 1 - > if [HELP_OUTPUT (help)]

    outputbuffer
    covr (os.args)
    (cstr.cpy)

    disc
    disc
    ret
end

proc openinput 1 0
  inputfd read
  copy != 0 if [(os.close) 0]
  disc

  cmdlineflags read ! if [
    0 1 (log.level)
    "SLM" covr (log.msg)
    (log.log)
  ]

  {open input}
  0
  swap
  fm.READ swap
  -100
  (os.open)
  inputfd swap put disc

  ret
end

proc parseinc 0 0
  includebuffer read NULL == if ret
  includebuffer
  includetmpbuffer
  do
    covr readc

    copy ',' ==
    if [
      includetmpbuffer (openinput)
      (parsefile)
      includetmpbuffer (cstr.clear) disc
      disc disc
      includetmpbuffer 0
    ]

    covr
    swap
    putc disc

    swap
    1 +
    swap
    copy readc 0 != if [
      1 +
    ]

    covr readc 0 !=
  end
  disc
  disc
  includetmpbuffer (openinput)
  (parsefile)
  includetmpbuffer (cstr.clear) disc

  ret
end

proc setinclude 1 1
    copy argc 1 - > if [HELP_OUTPUT (help)]

    includebuffer
    covr (os.args)
    (cstr.cpy)

    disc
    disc
    ret
end

proc setinput 1 0
  inputbuffer
  readc 0 != if [HELP_ARGS (help)]

  { set input to argument if its not a flag }
  inputbuffer
  covr (os.args)
  (cstr.cpy)

  { clean that }
  disc
  disc
  disc

  ret
end

{
args: ptr int
result: int int

checks the string for a match with an argument
if so returns 0 and runs argument
otherwise returns 1
}
proc applyarg 2 2
  copy "-h" (cstr.eq)
  if [disc HELP_SHOW (help) 0 ret]
  copy "--help" (cstr.eq)
  if [disc HELP_SHOW (help) 0 ret]
  copy "-v" (cstr.eq)
  if [disc HELP_VERSION (help) 0 ret]
  copy "-i" (cstr.eq)
  if [disc 1 + (setinclude) 0 ret]
  copy "--include" (cstr.eq)
  if [disc 1 + (setinclude) 0 ret]
  copy "-o" (cstr.eq)
  if [disc 1 + (setoutput) 0 ret]
  copy "--output" (cstr.eq)
  if [disc 1 + (setoutput) 0 ret]
  copy "-s" (cstr.eq)
  if [disc (setsilent) 0 ret]
  copy "--silent" (cstr.eq)
  if [disc (setsilent) 0 ret]
  copy "-a" (cstr.eq)
  if [disc (setasm) 0 ret]
  copy "--asm" (cstr.eq)
  if [disc (setasm) 0 ret]
  disc
  1 ret
end

proc nasm 0 0
  cmdtmpbuffer
  "/usr/bin/rgbasm" put int.SIZE +
  "-L" put int.SIZE +
  "-o" put int.SIZE +
  "temp.o" put int.SIZE +
  "temp.asm" put int.SIZE +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  ret
end

proc ld 0 0
  cmdtmpbuffer
  "/usr/bin/rgblink" put int.SIZE +
  "-o" put int.SIZE +
  outputbuffer put int.SIZE +
  "temp.o" put int.SIZE +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc
  
  cmdtmpbuffer
  "/usr/bin/rgbfix" put int.SIZE +
  "-v" put int.SIZE +
  "-p" put int.SIZE +
  "0xFF" put int.SIZE +
  "-t" put int.SIZE +
  "Tall Plant" put int.SIZE +
  outputbuffer put int.SIZE +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc

  cmdlineflags read 2 && 0 != if [
    ret
  ]

  cmdtmpbuffer
  "/usr/bin/rm" put int.SIZE +
  "temp.asm" put int.SIZE +
  NULL put disc

  cmdtmpbuffer
  cmdlineflags read 1 && ! if [(os.execcmdecho) 0]
  cmdlineflags read 1 && if [(os.execcmd) 0]
  disc
  
  ret
end

proc initobjs 0 0
  (heap.init)

  gvartab      TAB_KEY_SIZE BIG_TAB_CAP (tab.new) put disc
  consttab     TAB_KEY_SIZE BIG_TAB_CAP (tab.new) put disc
  proctab      TAB_KEY_SIZE BIG_TAB_CAP (tab.new) put disc
  procstacktab TAB_KEY_SIZE BIG_TAB_CAP (tab.new) put disc

  identstack   int.SIZE     IDENT_CAP   (seq.new) put disc
  
  ret
end

proc main 0 0
  { only cmd, then show help }
  1 argc == if [HELP_ARGS (help)]

  (initobjs)

  { iterate through args }
  0
  do
    { increment }
    1 +

    { get argument }
    copy (os.args)

    (applyarg) if [copy (setinput)]

    copy argc 1 - <
  end
  disc

  { if no output, put default }
  outputbuffer
  readc 0 ==
  if [outputbuffer "output" (cstr.cpy) disc disc]

  { if no input, write help message }
  inputbuffer
  readc 0 ==
  if [HELP_ARGS (help)]

  {open output}
  511
  65
  "temp.asm"
  -100
  (os.open)
  outputfd swap put disc

  {parse input}
  (asmheader)

  (parseinc)

  inputbuffer
  (openinput)

  (parsefile)

  (asmfooter)

  {close output}
  outputfd read (os.close)

  {close input}
  inputfd read (os.close)

  (nasm)
  (ld)

  (clean)

  0 quit

  ret
end
